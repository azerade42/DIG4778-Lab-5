using UnityEngine;
using UnityEngine.AI;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(NavMeshAgent))]
public class Avoider : MonoBehaviour
{
    [SerializeField] private Avoidee objToAvoid;
    [SerializeField] private float visionRange;
    [SerializeField] private float agentSpeed;
    [SerializeField] private bool showGizmos;
    [SerializeField] private float sampleTickRate = 2f;
    
    private NavMeshAgent agent;
    private AvoiderState avoiderState;
    private List<Vector2> samplesSeen = new List<Vector2>();
    private List<Vector2> samplesHidden = new List<Vector2>();
    private int sampleCount;
    private int sampleCountMax = 1;
    private float timeSinceLastSample;
    private float timeSinceLastSeen;

    private void Start()
    {
        agent = GetComponent<NavMeshAgent>();
        agent.speed = agentSpeed;
    }

    private void FixedUpdate()
    {
        // Check if there is an obstruction between the avoider and the avoidee
        if (Physics.Raycast(objToAvoid.transform.position, transform.position - objToAvoid.transform.position, out RaycastHit hitInfo))
        {
            // If there is a direct line of sight, start making the avoider run away
            if (hitInfo.collider.gameObject.GetComponent<Avoider>())
            {
                timeSinceLastSeen = 0;
                avoiderState = AvoiderState.Running;
            }
            else
            {
                // Stop the avoider if it has been more than a second since there has been a direct line of sight with the avoidee
                timeSinceLastSeen += Time.fixedDeltaTime;
                if (timeSinceLastSeen > 1f)
                {
                    avoiderState = AvoiderState.Stopped;
                }
            }

            if (avoiderState == AvoiderState.Running)
            {
                SampleValidMoves();
            }
            if (avoiderState == AvoiderState.Stopped)
            {
                print("Stopped since Avoider has not seen the avoidee for over a second");
                agent.velocity = Vector3.zero;
            }
        }

        // Move to a sample point and recalculate sample moves
        if (timeSinceLastSample > sampleTickRate)
        {
            MoveToClosestPoint();
            timeSinceLastSample = 0f;
            sampleCount = 0;
            samplesSeen = new List<Vector2>();
            samplesHidden = new List<Vector2>();
        }

        timeSinceLastSample += Time.fixedDeltaTime;
    }

   // Uses the PoissonDiscSampler to create and store valid and invalid hiding spots for the avoider to move to
    private void SampleValidMoves()
    {
        if (++sampleCount > sampleCountMax) return;

        PoissonDiscSampler sampler = new PoissonDiscSampler(visionRange*2, visionRange*2, 1f);
        foreach (Vector2 sample in sampler.Samples())
        {
            Vector2 offsetSample = new Vector2(transform.position.x + sample.x - visionRange, transform.position.z + sample.y - visionRange);
            Vector3 raycastDirection = new Vector3(offsetSample.x, 1, offsetSample.y) - objToAvoid.transform.position;
            
            if (Physics.Raycast(objToAvoid.transform.position, raycastDirection,  out RaycastHit hitInfo, raycastDirection.magnitude))
            {
                // Sample position is behind the Avoider and therefore seen by the avoidee
                if (hitInfo.collider.gameObject.GetComponent<Avoider>())
                {
                    samplesSeen.Add(offsetSample);
                }
                // Sample position is behind anything that isn't the avoider and is therefore hidden from the Avoidee
                else
                {
                    samplesHidden.Add(offsetSample);
                }
            }
            // Sample position does not have an obstruction from avoidee
            else
            {
                samplesSeen.Add(offsetSample);
            }
        }
    }

    // Uses the hidden points generated by the sampler to determine the closest point for the avoider to move to
    private void MoveToClosestPoint()
    {
        float closestPointDistance = float.MaxValue;
        NavMeshPath path = null;
        NavMeshPath shortestPath = null;

        for (int i = 0; i < samplesHidden.Count(); i++)
        {
            Vector2 currentPoint = samplesHidden.ElementAt(i);
            if (currentPoint == null) continue;

            path = new NavMeshPath();

            if (NavMesh.CalculatePath(transform.position, new Vector3(currentPoint.x, 1, currentPoint.y), agent.areaMask, path))
            {
                float dist = Vector3.Distance(transform.position, path.corners[0]);

                for (int j = 1; j < path.corners.Length; j++)
                {
                    dist += Vector3.Distance(path.corners[j - 1], path.corners[0]);
                }

                if (dist < closestPointDistance)
                {
                    closestPointDistance = dist;
                    shortestPath = path;
                }
            }
        }

        if (shortestPath != null)
        {
            agent.SetPath(shortestPath);
        }
    }

    // Visualizes the sample points that the avoider tries to move to every tick
    private void OnDrawGizmos()
    {
        if (!showGizmos) return;

        Gizmos.color = Color.white;
        Gizmos.DrawRay(objToAvoid.transform.position, transform.position - objToAvoid.transform.position);

        DrawSamples(samplesSeen, Color.red);
        DrawSamples(samplesHidden, Color.green);
    }

    private void DrawSamples(List<Vector2> samplePoints, Color lineColor)
    {
        List<Vector3> pointsToDraw = new List<Vector3>();
        foreach (Vector2 point in samplePoints)
        {
            pointsToDraw.Add(transform.position);
            pointsToDraw.Add(new Vector3(point.x, 1, point.y));

            // debugging raycast from Avoidee
            // Gizmos.color = Color.blue;
            // Vector3 raycastDirection = new Vector3(point.x, 1, point.y) - objToAvoid.transform.position;
            // Gizmos.DrawRay(objToAvoid.transform.position, raycastDirection);
        }
        Gizmos.color = lineColor;
        Gizmos.DrawLineList(pointsToDraw.ToArray());
    }
}
